
{% include 'header.html' %}

<div class="container">
  <h1>HW7 â€“ Stereo Size Estimation and Real-time Pose &amp; Hand Tracking</h1>

  <!-- Real-time (1 FPS) webcam-based pose & hand tracking ONLY -->
  <div class="box">
    <a href="https://drive.google.com/file/d/1rw9fGYkZ3CxwvSC-RMW9q2TBRbU2uj_Z/view?usp=sharing">Video</a>
    <h2>Real-time Pose &amp; Hand Tracking (Webcam, ~1 FPS, Mediapipe)</h2>

    <p>
      A frame is captured approximately once per second from the webcam, sent to the
      server, processed by Mediapipe, and only the <strong>processed frame</strong>
      (with skeleton and hand overlays) is displayed below. The raw webcam feed is
      not shown. All detected keypoints are continuously appended to a CSV file
      for this session.
    </p>

    <!-- Hidden video element used only as a capture source -->
    <video id="rt_video" autoplay playsinline muted style="display:none;"></video>

    <div class="form-row">
      <button id="start_rt">Start Real-Time</button>
      <button id="stop_rt">Stop</button>
    </div>

    <div id="rt_result" class="result-box">
      <p id="rt_status">Processed webcam output will appear here.</p>
      <img id="rt_image" alt="RT preview" style="display:none;">
    </div>

    <div class="form-row">
      <a id="rt_csv_link" href="#" style="display:none;">Download CSV (this session)</a>
    </div>

    <div id="rt_error_box" class="error-box" style="display:none;"></div>
  </div>
</div>

<style>
  .container {
    max-width: 960px;
    margin: 0 auto;
    padding: 16px;
    font-family: Arial, sans-serif;
  }
  .box {
    border: 1px solid #ccc;
    padding: 16px;
    margin-bottom: 20px;
    border-radius: 4px;
    background-color: #fafafa;
  }
  .form-row {
    margin-bottom: 12px;
  }
  .result-box {
    min-height: 320px; /* keep layout stable */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
  }
  #rt_image {
    max-width: 100%;
    border: 1px solid #ccc;
    margin-top: 8px;
  }
  .error-box {
    margin-top: 12px;
    padding: 8px;
    border: 1px solid #c00;
    background-color: #fee;
    color: #900;
  }
  pre {
    white-space: pre-wrap;
    font-size: 0.9em;
  }
</style>

<script>
document.addEventListener("DOMContentLoaded", function () {
  // Real-time (1 FPS) webcam pose/hand
  const rtVideo = document.getElementById("rt_video"); // hidden source
  const rtImage = document.getElementById("rt_image");
  const rtStatus = document.getElementById("rt_status");
  const startRtBtn = document.getElementById("start_rt");
  const stopRtBtn = document.getElementById("stop_rt");
  const rtErrorBox = document.getElementById("rt_error_box");
  const rtCsvLink = document.getElementById("rt_csv_link");

  let rtStream = null;
  let rtInterval = null;
  let runId = null; // unique per start/stop session

  function generateRunId() {
    return Date.now().toString(36) + "_" + Math.random().toString(36).slice(2, 8);
  }

  async function captureFrame(videoElem) {
    if (!videoElem.videoWidth || !videoElem.videoHeight) {
      return null;
    }
    const canvas = document.createElement("canvas");
    canvas.width = videoElem.videoWidth;
    canvas.height = videoElem.videoHeight;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(videoElem, 0, 0);
    const blob = await new Promise((resolve) =>
      canvas.toBlob(resolve, "image/jpeg")
    );
    return blob;
  }

  startRtBtn.addEventListener("click", async function () {
    rtErrorBox.style.display = "none";
    rtErrorBox.textContent = "";
    rtStatus.textContent = "Starting webcam...";
    rtImage.style.display = "none";
    rtCsvLink.style.display = "none";

    runId = generateRunId();

    try {
      rtStream = await navigator.mediaDevices.getUserMedia({ video: true });
      rtVideo.srcObject = rtStream; // hidden but used as capture source
      rtStatus.textContent = "Webcam running. Processing at ~1 FPS...";
    } catch (err) {
      rtErrorBox.textContent = "Failed to access webcam: " + err;
      rtErrorBox.style.display = "block";
      rtStatus.textContent = "No webcam.";
      return;
    }

    if (rtInterval) {
      clearInterval(rtInterval);
    }

    rtInterval = setInterval(async () => {
      const frameBlob = await captureFrame(rtVideo);
      if (!frameBlob) {
        return;
      }

      const fd = new FormData();
      fd.append("frame", frameBlob, "frame.jpg");
      fd.append("run_id", runId);

      fetch("/api/hw7_pose_frame", {
        method: "POST",
        body: fd,
      })
        .then((r) => r.json())
        .then((data) => {
          if (!data.success) {
            rtErrorBox.textContent = data.error || "Frame processing failed.";
            rtErrorBox.style.display = "block";
            rtStatus.textContent = "Error.";
            rtImage.style.display = "none";
            return;
          }
          rtErrorBox.style.display = "none";
          rtErrorBox.textContent = "";
          rtStatus.textContent = "Streaming (~1 FPS)...";

          // update processed image only
          rtImage.src = data.preview_image_url + "?t=" + Date.now();
          rtImage.style.display = "block";

          if (data.csv_url) {
            rtCsvLink.href = data.csv_url;
            rtCsvLink.style.display = "inline";
          }
        })
        .catch((err) => {
          rtErrorBox.textContent = "Request failed: " + err;
          rtErrorBox.style.display = "block";
          rtStatus.textContent = "Error.";
          rtImage.style.display = "none";
        });
    }, 1000); // 1 frame per second
  });

  stopRtBtn.addEventListener("click", function () {
    if (rtInterval) {
      clearInterval(rtInterval);
      rtInterval = null;
    }
    if (rtStream) {
      rtStream.getTracks().forEach((t) => t.stop());
      rtStream = null;
    }
    rtStatus.textContent = "Stopped.";
    rtImage.style.display = "none";
  });
});
</script>
